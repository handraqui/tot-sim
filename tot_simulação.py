# -*- coding: utf-8 -*-
"""TOT - Simulação

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KYOmvMPGIxAWzQ6XDVqMEGzH4g9YRAT8

Mudei o nome deste notebook porque não estou achando o outro que eu criei :P

Edit 1 (25/11/18 - 11:47 Henrique): Como sugeri no whatsapp, incorporei as funções criadas pelo Leonardo. Com isso, passo a trabalhar sobre elas.
"""

from IPython.core.display import display, HTML
display(HTML("<style>.container { width:100% !important; }</style>"))

from random import randint

def Contains(A,B):

  for b in B:
        
    if(b not in A):
            
      return False
        
  return True

def Heirs(vertex,graph):
    
  N = len(graph)
    
  heirs = [j for j in range(N) if graph[vertex][j] == 1]
    
  return heirs

def Multi_Heirs(vertexes, graph):
    
  multi_heirs = [Heirs(i,graph) for i in vertexes]
    
  multi_heirs = [n for sub in multi_heirs for n in sub]
    
  return list(set(multi_heirs))

def Reachables(vertex, graph):
 
  reachables = []
    
  new_reachables = Heirs(vertex, graph)
    
  while(not Contains(reachables, new_reachables)):
        
    reachables += new_reachables
    reachables = list(set(reachables))
        
    new_reachables += Multi_Heirs(new_reachables, graph)
    new_reachables = list(set(new_reachables))
        
  
  return reachables

def Has_Cycle(graph):
    
  N = len(graph)
    
  for i in range(N):
        
    if(i in Reachables(i,graph)):
            
      return True
        
  return False

g = [[0,1,0],[1,0,0],[0,0,0]]

Has_Cycle(g)

def RanDAG(n_vertexes, n_edges):
    
  assert( n_edges <= (n_vertexes-1)*(n_vertexes)/2)
    
  ranDag = [[0 for _ in range(n_vertexes)] for _ in range(n_vertexes)]

  edge_count = 0
    
  while(edge_count < n_edges):
        
    i = randint(0,n_vertexes-1)
    j = randint(0,n_vertexes-1)
        
    if( ranDag[i][j] == 0 ):
    
      ranDag[i][j] = 1
            
      if( Has_Cycle(ranDag) ):
        
        ranDag[i][j] = 0
            
      else:
                
        edge_count += 1
               
  return ranDag

RanDAG(15,80)

def Distribute(graph):
  
  N = len(graph)
  
  distributed_graph = [[0 for _ in range(N)] for _ in range(N)]
  
  for i in range(N):
    
    total_weight = sum(graph[i])
    
    for j in range(N):
      
      if( graph[i][j] == 1 ):
        
          distributed_graph[i][j] = 1 / total_weight
          
  return distributed_graph